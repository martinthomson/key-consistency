



Network Working Group                                        A. Davidson
Internet-Draft                                                LIP Lisboa
Intended status: Informational                                M. Thomson
Expires: 26 August 2021                                          Mozilla
                                                               C.A. Wood
                                                              Cloudflare
                                                        22 February 2021


                     Key Consistency and Discovery
                   draft-wood-key-consistency-latest

Abstract

   This document describes the key consistency and correctness
   requirements of protocols such as Privacy Pass, Oblivious DoH, and
   Oblivious HTTP for user privacy.  It discusses several mechanisms and
   proposals for enabling user privacy in varying threat models.  In
   concludes with discussion of open problems in this area.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the mailing list (), which
   is archived at .

   Source for this draft and an issue tracker can be found at
   https://github.com/chris-wood/key-consitency.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 26 August 2021.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements
   2.  Core Requirements
   3.  Deploying Consistency and Correctness
     3.1.  Server-Provided Key Discovery
     3.2.  Proxy-Based Key Discovery
     3.3.  Log-Based Key Discovery
     3.4.  Anonymous System Key Discovery
     3.5.  Minimum Validity Periods
   4.  Future Work
   5.  Security Considerations
   6.  References
     6.1.  Normative References
     6.2.  Informative References
   Authors' Addresses

1.  Introduction

   Several proposed privacy-enhancing protocols such as Privacy Pass
   [PRIVACY-PASS], Oblivious DoH [ODOH], and Oblivious HTTP [OHTTP]
   require clients to obtain and use a public key for execution.  For
   example, Privacy Pass public keys are used by clients for validating
   privately issued tokens for anonymous session resumption.  Oblivious
   DoH and HTTP both use public keys to encrypt messages to a particular
   server.  In all cases, a common security goal is that recipients
   cannot link usage of a public key to a specific (set of) user(s).  In
   other words, all users of a public key should belong to the same
   anonymity set, and an attacker should not be able to actively reduce
   the size of this anonymity set.  Moreover, an attacker should not be
   able to convince users to use a key that does not belong to the
   intended server.

   In this document, we elaborate on these core requirements, and survey
   various system designs that might be used to satisfy them.  The
   purpose of this document is to highlight challenges in building and
   deploying solutions to this problem.

1.1.  Requirements

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.  Core Requirements

   Privacy-focused protocols which rely on widely shared public keys
   typically require keys be consistent and correct.  Informally, key
   consistency is the requirement that all users of a key share the same
   view of the key.  Some protocols depend on large sets of users with
   consistent keys for privacy reasons.  Specifically, all users with a
   consistent key represent an anonymity set wherein each user of the
   key in that set is indistinguishable from the rest.  An attacker that
   can actively cause inconsistent views of keys can therefore
   compromise user privacy.

   An attacker may separately cause privacy problems by forcing an users
   in an anonymity set to use an incorrect key.  Informally, a key is
   correct if it belongs to the intended server and is not otherwise
   available to an attacker.  In a public key setting, this means that
   the public key is that which is owned by the corresponding owner, and
   only that owner has access to the private key.  An attacker that can
   actively cause users to make use of incorrect keys may be able to
   compromise user privacy.

   Systems must also consider agility when trying to satisfy these
   requirements.  A naive solution to ensuring consistent and correct
   keys is to only use a single, fixed key pair for the entirety of the
   system.  Users can then embed this key into software or elsewhere as
   needed, without any additional mechanics or controls to ensure that
   other users have a different key.  However, this solution clearly is
   not viable in practice.  If the corresponding key is compromised, the
   system fails.  Rotation must therefore be supported, and in doing so,
   users need some mechanism to ensure that rotated newly rotated keys
   are consistent and correct.  Operationally, servers rotating keys may
   likely need to accommodate distributed system state-synchronization
   issues without sacrificing availability.  Some systems and protocols
   may choose to prioritize strong consistency over availability, but
   this document assumes that availability is preferred to consistency.

3.  Deploying Consistency and Correctness

   There are a variety of ways in systems may build systems for ensuring
   key consistency and correctness, ranging in operational complexity to
   ease-of-implementation.  In this section, we survey a number of
   possible solutions.  The viability of each varies depending on the
   applicable threat model, external dependencies, and overall system
   requirements.  We do not include the fixed public key model from
   Section 2, as this is likely not a viable solution for systems and
   protocols in practice.  In all scenarios, the server corresponding to
   the desired key is considered malicious.

3.1.  Server-Provided Key Discovery

   In this model, users would directly query servers for their
   corresponding public key.  The properties of this solution depend on
   external mechanisms in place to ensure consistency or correctness.
   Absent any such mechanisms, servers can produce unique keys for users
   without detection.  External mechanisms to ensure consistency here
   might include, though are not limited to:

   *  Presenting a signed assertion from a trusted entity that the key
      is unique.

   *  Presenting proof that the key is present in some tamper-proof log,
      similar to Certificate Transparency ([RFC6962]) logs.

   *  User communication or gossip ensuring that all users have a shared
      view of the key.

   The precise external mechanism used here depends largely on the
   threat model.  If there is a trusted external log for keys, this may
   be a viable solution.

3.2.  Proxy-Based Key Discovery

   In this model, there exists a proxy that fetches keys from servers on
   behalf of multiple users.  If this proxy is trusted, then all users
   which request a key from this server are assured they have a
   consistent view of the server key.  However, if this proxy is not
   trusted, operational risks may arise:

   *  The proxy can collude with the server to give per-user keys to
      clients.

   *  The proxy can give all users a key owned by the proxy, and either
      collude with the server to use this key or retroactively use this
      key to compromise user privacy when users later make use of the
      key.

   Mitigating these risks may require tamper-proof logs as in
   Section 3.1, or via user gossip protocols.

3.3.  Log-Based Key Discovery

   In this model, servers publish keys in a tamper-proof log similar to
   that of Certificate Transparency [RFC6962].  Users may then fetch
   keys directly from the server and subsequently verify their existence
   in the log.  The log is operated and audited in such a way that the
   contents of the log are consistent for all users.  Any system which
   depends on this type of system requires the log be audited or users
   have some other mechanism for checking their view of the log state
   (gossiping).  However, this type of system does not ensure proactive
   security against malicious servers unless log participants actively
   check log proofs.  This requirement may impede deployment in
   practice, given that no web browser checks
   SignedCertificateTimestamps before using (accepting as valid) a
   corresponding TLS certificate.

3.4.  Anonymous System Key Discovery

   In this model, users leverage an anonymity network such as Tor to
   fetch keys directly from servers over multiple vantage points.
   Depending on how clients fetch such keys from servers, it may become
   more difficult for servers to uniquely target individual users with
   unique keys without detection.  This is especially true as the number
   of users of these anonymity networks increases.  However, beyond Tor,
   there does not exist a special-purpose anonymity network for this
   purpose.

3.5.  Minimum Validity Periods

   In addition to ensuring that there is one key at any time, or a
   limited number keys, any system needs to ensure that a server cannot
   rotate its keys too often in order to divide clients into smaller
   groups based on when keys are acquired.  Such considerations are
   already highlighted within the Privacy Pass ecosystem, more
   discussion can be found at [PRIVACY-PASS-ARCH].  Setting a minimum
   validity period limits the ability of a server to rotate keys, but
   also limits the rate of key rotation.

4.  Future Work

   The model in Section 3.4 seems to be the most lightweight and easy-
   to-deploy mechanism for ensuring key consistency and correctness.
   However, it remains unclear if there exists such an anonymity network
   that can scale to the widespread adoption of and requirements of
   protocols like Privacy Pass, Oblivious DoH, or Oblivious HTTP.
   Existing infrastructure based on technologies like Certificate
   Transparency or Key Transparency may work, but there is currently no
   general purpose system for transparency of opaque keys (or other
   application data).

5.  Security Considerations

   This document discusses several models that systems might use to
   implement public key discovery while ensuring key consistency and
   correctness.  It does not make any recommendations for such models as
   the best model depends on differing operational requirements and
   threat models.

6.  References

6.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://datatracker.ietf.org/doc/html/rfc2119>.

   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate
              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,
              <https://datatracker.ietf.org/doc/html/rfc6962>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://datatracker.ietf.org/doc/html/rfc7748>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://datatracker.ietf.org/doc/html/rfc8174>.

6.2.  Informative References

   [ODOH]     Kinnear, E., McManus, P., Pauly, T., and C. A. Wood,
              "Oblivious DNS Over HTTPS", Work in Progress, Internet-
              Draft, draft-pauly-dprive-oblivious-doh-05, 21 February
              2021, <https://datatracker.ietf.org/doc/html/draft-pauly-
              dprive-oblivious-doh-05.txt>.

   [OHTTP]    Thomson, M. and C. A. Wood, "Oblivious HTTP", Work in
              Progress, Internet-Draft, draft-thomson-http-oblivious-01,
              21 February 2021, <https://datatracker.ietf.org/doc/html/
              draft-thomson-http-oblivious-01.txt>.

   [PRIVACY-PASS]
              Celi, S., Davidson, A., and A. Faz-Hernandez, "Privacy
              Pass Protocol Specification", Work in Progress, Internet-
              Draft, draft-ietf-privacypass-protocol-01, 22 February
              2021, <https://datatracker.ietf.org/doc/html/draft-ietf-
              privacypass-protocol-01.txt>.

   [PRIVACY-PASS-ARCH]
              Davidson, A. and C. A. Wood, "Privacy Pass Architectural
              Framework", Work in Progress, Internet-Draft, draft-ietf-
              privacypass-architecture-01, 22 February 2021,
              <https://datatracker.ietf.org/doc/html/draft-ietf-
              privacypass-architecture-01.txt>.

Authors' Addresses

   Alex Davidson
   LIP Lisboa

   Email: alex.davidson92@gmail.com


   Martin Thomson
   Mozilla

   Email: mt@lowentropy.net


   Christopher A. Wood
   Cloudflare
   101 Townsend St
   San Francisco,
   United States of America

   Email: caw@heapingbits.net
